const questions=[
  {
    "num": 1,
    "question_en": "What is 'maximum munch rule' in lexical analysis?",
    "question_hi": "लेक्सिकल विश्लेषण में 'maximum munch rule' क्या है?",
    "options_en": ["Compiler takes longest possible token", "Shortest token", "First token", "Random token"],
    "options_hi": ["कंपाइलर सबसे लंबा संभव टोकन लेता है", "सबसे छोटा टोकन", "पहला टोकन", "यादृच्छिक टोकन"],
    "answer_en": "Compiler takes longest possible token",
    "answer_hi": "कंपाइलर सबसे लंबा संभव टोकन लेता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 2,
    "question_en": "What is 'pseudo-random sequence' generated by rand()?",
    "question_hi": "rand() द्वारा उत्पन्न 'pseudo-random sequence' क्या है?",
    "options_en": ["Deterministic sequence based on seed", "Truly random", "Hardware random", "No sequence"],
    "options_hi": ["बीज पर आधारित निर्धारक क्रम", "वास्तव में यादृच्छिक", "हार्डवेयर यादृच्छिक", "कोई क्रम नहीं"],
    "answer_en": "Deterministic sequence based on seed",
    "answer_hi": "बीज पर आधारित निर्धारक क्रम",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 3,
    "question_en": "What is 'address space layout randomization' (ASLR) effect on C?",
    "question_hi": "'address space layout randomization' (ASLR) का C पर क्या प्रभाव है?",
    "options_en": ["Stack/heap addresses change each run", "Fixed addresses", "No effect", "Only for kernel"],
    "options_hi": ["स्टैक/हीप पते प्रत्येक रन पर बदलते हैं", "निश्चित पते", "कोई प्रभाव नहीं", "केवल कर्नेल के लिए"],
    "answer_en": "Stack/heap addresses change each run",
    "answer_hi": "स्टैक/हीप पते प्रत्येक रन पर बदलते हैं",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 4,
    "question_en": "What is 'non-reentrant function' problem with signals?",
    "question_hi": "सिग्नल के साथ 'non-reentrant function' समस्या क्या है?",
    "options_en": ["Function uses static data; unsafe in signal handler", "No problem", "Always safe", "Only for malloc"],
    "options_hi": ["फ़ंक्शन स्थैतिक डेटा का उपयोग करता है; सिग्नल हैंडलर में असुरक्षित", "कोई समस्या नहीं", "हमेशा सुरक्षित", "केवल malloc के लिए"],
    "answer_en": "Function uses static data; unsafe in signal handler",
    "answer_hi": "फ़ंक्शन स्थैतिक डेटा का उपयोग करता है; सिग्नल हैंडलर में असुरक्षित",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 5,
    "question_en": "What is 'strict overflow' compiler option?",
    "question_hi": "'strict overflow' कंपाइलर विकल्प क्या है?",
    "options_en": ["Compiler assumes no signed overflow (for optimization)", "Allows overflow", "Checks overflow", "No such option"],
    "options_hi": ["कंपाइलर मानता है कोई हस्ताक्षरित ओवरफ्लो नहीं (ऑप्टिमाइज़ेशन के लिए)", "ओवरफ्लो की अनुमति देता है", "ओवरफ्लो जाँचता है", "ऐसा कोई विकल्प नहीं"],
    "answer_en": "Compiler assumes no signed overflow (for optimization)",
    "answer_hi": "कंपाइलर मानता है कोई हस्ताक्षरित ओवरफ्लो नहीं (ऑप्टिमाइज़ेशन के लिए)",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 6,
    "question_en": "What is 'strict aliasing' optimization?",
    "question_hi": "'strict aliasing' ऑप्टिमाइज़ेशन क्या है?",
    "options_en": ["Compiler assumes pointers of different types don't alias", "Always alias", "No assumption", "Only for arrays"],
    "options_hi": ["कंपाइलर मानता है कि विभिन्न प्रकार के पॉइंटर्स एलियास नहीं करते", "हमेशा एलियास", "कोई धारणा नहीं", "केवल ऐरे के लिए"],
    "answer_en": "Compiler assumes pointers of different types don't alias",
    "answer_hi": "कंपाइलर मानता है कि विभिन्न प्रकार के पॉइंटर्स एलियास नहीं करते",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 7,
    "question_en": "What is 'type-based alias analysis' (TBAA)?",
    "question_hi": "'type-based alias analysis' (TBAA) क्या है?",
    "options_en": ["Optimization using type info to determine aliasing", "No analysis", "Only for pointers", "Runtime analysis"],
    "options_hi": ["एलियासिंग निर्धारित करने के लिए टाइप जानकारी का उपयोग कर ऑप्टिमाइज़ेशन", "कोई विश्लेषण नहीं", "केवल पॉइंटर्स के लिए", "रनटाइम विश्लेषण"],
    "answer_en": "Optimization using type info to determine aliasing",
    "answer_hi": "एलियासिंग निर्धारित करने के लिए टाइप जानकारी का उपयोग कर ऑप्टिमाइज़ेशन",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 8,
    "question_en": "What is 'dead store elimination'?",
    "question_hi": "'dead store elimination' क्या है?",
    "options_en": ["Removing stores to variables never read", "Keeping all stores", "No elimination", "Only for globals"],
    "options_hi": ["कभी न पढ़े जाने वाले वेरिएबल्स को स्टोर हटाना", "सभी स्टोर रखना", "कोई उन्मूलन नहीं", "केवल ग्लोबल्स के लिए"],
    "answer_en": "Removing stores to variables never read",
    "answer_hi": "कभी न पढ़े जाने वाले वेरिएबल्स को स्टोर हटाना",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 9,
    "question_en": "What is 'common subexpression elimination'?",
    "question_hi": "'common subexpression elimination' क्या है?",
    "options_en": ["Reusing computed value of identical expressions", "Recomputing always", "No elimination", "Only for constants"],
    "options_hi": ["समान एक्सप्रेशन के परिकलित मान का पुनः उपयोग", "हमेशा पुनर्गणना", "कोई उन्मूलन नहीं", "केवल स्थिरांक के लिए"],
    "answer_en": "Reusing computed value of identical expressions",
    "answer_hi": "समान एक्सप्रेशन के परिकलित मान का पुनः उपयोग",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 10,
    "question_en": "What is 'strength reduction'?",
    "question_hi": "'strength reduction' क्या है?",
    "options_en": ["Replacing expensive operation with cheaper (e.g., multiply with shift)", "No reduction", "Making stronger", "Only for loops"],
    "options_hi": ["महंगी संक्रिया को सस्ती से बदलना (जैसे, शिफ्ट के साथ गुणा)", "कोई कमी नहीं", "मजबूत बनाना", "केवल लूप के लिए"],
    "answer_en": "Replacing expensive operation with cheaper (e.g., multiply with shift)",
    "answer_hi": "महंगी संक्रिया को सस्ती से बदलना (जैसे, शिफ्ट के साथ गुणा)",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 11,
    "question_en": "What is 'loop jamming' (fusion)?",
    "question_hi": "'loop jamming' (fusion) क्या है?",
    "options_en": ["Combining adjacent loops with same bounds", "Splitting loops", "No fusion", "Only for nested loops"],
    "options_hi": ["समान सीमा वाले आसन्न लूप को संयोजित करना", "लूप विभाजित करना", "कोई संलयन नहीं", "केवल नेस्टेड लूप के लिए"],
    "answer_en": "Combining adjacent loops with same bounds",
    "answer_hi": "समान सीमा वाले आसन्न लूप को संयोजित करना",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 12,
    "question_en": "What is 'loop splitting' (distribution)?",
    "question_hi": "'loop splitting' (distribution) क्या है?",
    "options_en": ["Splitting loop body into separate loops", "Combining loops", "No splitting", "Only for small loops"],
    "options_hi": ["लूप बॉडी को अलग-अलग लूप में विभाजित करना", "लूप संयोजित करना", "कोई विभाजन नहीं", "केवल छोटे लूप के लिए"],
    "answer_en": "Splitting loop body into separate loops",
    "answer_hi": "लूप बॉडी को अलग-अलग लूप में विभाजित करना",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 13,
    "question_en": "What is 'loop interchange'?",
    "question_hi": "'loop interchange' क्या है?",
    "options_en": ["Swapping inner and outer loops for better cache locality", "No interchange", "Only for 2 loops", "Random swapping"],
    "options_hi": ["बेहतर कैश स्थानीयता के लिए आंतरिक और बाहरी लूप स्वैप करना", "कोई अदला-बदली नहीं", "केवल 2 लूप के लिए", "यादृच्छिक स्वैपिंग"],
    "answer_en": "Swapping inner and outer loops for better cache locality",
    "answer_hi": "बेहतर कैश स्थानीयता के लिए आंतरिक और बाहरी लूप स्वैप करना",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 14,
    "question_en": "What is 'loop tiling' (blocking)?",
    "question_hi": "'loop tiling' (blocking) क्या है?",
    "options_en": ["Processing data in blocks to fit cache", "No tiling", "Only for images", "Random blocks"],
    "options_hi": ["कैश में फिट होने के लिए ब्लॉक में डेटा प्रसंस्करण", "कोई टाइलिंग नहीं", "केवल छवियों के लिए", "यादृच्छिक ब्लॉक"],
    "answer_en": "Processing data in blocks to fit cache",
    "answer_hi": "कैश में फिट होने के लिए ब्लॉक में डेटा प्रसंस्करण",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 15,
    "question_en": "What is 'software pipelining'?",
    "question_hi": "'software pipelining' क्या है?",
    "options_en": ["Overlap iterations to hide latency", "No overlapping", "Only hardware", "Only for vector"],
    "options_hi": ["विलंबता छिपाने के लिए पुनरावृत्तियों को ओवरलैप करें", "कोई ओवरलैपिंग नहीं", "केवल हार्डवेयर", "केवल वेक्टर के लिए"],
    "answer_en": "Overlap iterations to hide latency",
    "answer_hi": "विलंबता छिपाने के लिए पुनरावृत्तियों को ओवरलैप करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 16,
    "question_en": "What is 'vectorization'?",
    "question_hi": "'vectorization' क्या है?",
    "options_en": ["Using SIMD instructions for parallel operations", "No parallelism", "Only scalar", "Only for floats"],
    "options_hi": ["समानांतर संक्रियाओं के लिए SIMD निर्देशों का उपयोग", "कोई समानता नहीं", "केवल अदिश", "केवल फ़्लोट्स के लिए"],
    "answer_en": "Using SIMD instructions for parallel operations",
    "answer_hi": "समानांतर संक्रियाओं के लिए SIMD निर्देशों का उपयोग",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 17,
    "question_en": "What is 'if conversion'?",
    "question_hi": "'if conversion' क्या है?",
    "options_en": ["Convert conditional branches to conditional moves/predication", "No conversion", "Only for loops", "Random conversion"],
    "options_hi": ["सशर्त शाखाओं को सशित चाल/पूर्वनिर्धारण में बदलें", "कोई रूपांतरण नहीं", "केवल लूप के लिए", "यादृच्छिक रूपांतरण"],
    "answer_en": "Convert conditional branches to conditional moves/predication",
    "answer_hi": "सशित शाखाओं को सशित चाल/पूर्वनिर्धारण में बदलें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 18,
    "question_en": "What is 'speculative execution' at compiler level?",
    "question_hi": "कंपाइलर स्तर पर 'speculative execution' क्या है?",
    "options_en": ["Execute instructions before knowing if needed", "Always execute", "Never speculate", "Only for branches"],
    "options_hi": ["आवश्यकता जानने से पहले निर्देश निष्पादित करें", "हमेशा निष्पादित करें", "कभी अटकल नहीं", "केवल शाखाओं के लिए"],
    "answer_en": "Execute instructions before knowing if needed",
    "answer_hi": "आवश्यकता जानने से पहले निर्देश निष्पादित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 19,
    "question_en": "What is 'profile-guided optimization' feedback?",
    "question_hi": "'profile-guided optimization' प्रतिक्रिया क्या है?",
    "options_en": ["Runtime profile data fed back to compiler", "No feedback", "Static analysis", "Only for size"],
    "options_hi": ["रनटाइम प्रोफ़ाइल डेटा कंपाइलर को वापस फीड किया गया", "कोई प्रतिक्रिया नहीं", "स्थैतिक विश्लेषण", "केवल आकार के लिए"],
    "answer_en": "Runtime profile data fed back to compiler",
    "answer_hi": "रनटाइम प्रोफ़ाइल डेटा कंपाइलर को वापस फीड किया गया",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 20,
    "question_en": "What is 'link-time optimization' (LTO) granularity?",
    "question_hi": "'link-time optimization' (LTO) सूक्ष्मता क्या है?",
    "options_en": ["Whole program optimization across object files", "Only within file", "No cross-file", "Only for libraries"],
    "options_hi": ["ऑब्जेक्ट फ़ाइलों में संपूर्ण प्रोग्राम ऑप्टिमाइज़ेशन", "केवल फ़ाइल के भीतर", "कोई क्रॉस-फ़ाइल नहीं", "केवल लाइब्रेरी के लिए"],
    "answer_en": "Whole program optimization across object files",
    "answer_hi": "ऑब्जेक्ट फ़ाइलों में संपूर्ण प्रोग्राम ऑप्टिमाइज़ेशन",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 21,
    "question_en": "What is 'IPO' (Interprocedural Optimization)?",
    "question_hi": "'IPO' (Interprocedural Optimization) क्या है?",
    "options_en": ["Optimizations across function boundaries", "Only within function", "No cross-function", "Only for small functions"],
    "options_hi": ["फ़ंक्शन सीमाओं में ऑप्टिमाइज़ेशन", "केवल फ़ंक्शन के भीतर", "कोई क्रॉस-फ़ंक्शन नहीं", "केवल छोटे फ़ंक्शन के लिए"],
    "answer_en": "Optimizations across function boundaries",
    "answer_hi": "फ़ंक्शन सीमाओं में ऑप्टिमाइज़ेशन",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 22,
    "question_en": "What is 'function cloning'?",
    "question_hi": "'function cloning' क्या है?",
    "options_en": ["Create specialized version of function for specific arguments", "No cloning", "Only for recursion", "Random cloning"],
    "options_hi": ["विशिष्ट तर्कों के लिए फ़ंक्शन का विशिष्ट संस्करण बनाएं", "कोई क्लोनिंग नहीं", "केवल पुनरावृत्ति के लिए", "यादृच्छिक क्लोनिंग"],
    "answer_en": "Create specialized version of function for specific arguments",
    "answer_hi": "विशिष्ट तर्कों के लिए फ़ंक्शन का विशिष्ट संस्करण बनाएं",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 23,
    "question_en": "What is 'partial redundancy elimination'?",
    "question_hi": "'partial redundancy elimination' क्या है?",
    "options_en": ["Move computation to dominate all paths where it's used", "No elimination", "Only full redundancy", "Random movement"],
    "options_hi": ["गणना को सभी पथों पर हावी करने के लिए ले जाएँ जहाँ इसका उपयोग किया जाता है", "कोई उन्मूलन नहीं", "केवल पूर्ण अतिरेक", "यादृच्छिक आंदोलन"],
    "answer_en": "Move computation to dominate all paths where it's used",
    "answer_hi": "गणना को सभी पथों पर हावी करने के लिए ले जाएँ जहाँ इसका उपयोग किया जाता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 24,
    "question_en": "What is 'global value numbering'?",
    "question_hi": "'global value numbering' क्या है?",
    "options_en": ["Assign unique numbers to equivalent expressions globally", "No numbering", "Only local", "Random numbers"],
    "options_hi": ["समकक्ष व्यंजकों को विश्व स्तर पर अद्वितीय संख्या निर्दिष्ट करें", "कोई नंबरिंग नहीं", "केवल स्थानीय", "यादृच्छिक संख्या"],
    "answer_en": "Assign unique numbers to equivalent expressions globally",
    "answer_hi": "समकक्ष व्यंजकों को विश्व स्तर पर अद्वितीय संख्या निर्दिष्ट करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 25,
    "question_en": "What is 'scalar replacement of aggregates'?",
    "question_hi": "'scalar replacement of aggregates' क्या है?",
    "options_en": ["Replace struct/array with individual scalars", "No replacement", "Only for arrays", "Only for structs"],
    "options_hi": ["संरचना/ऐरे को व्यक्तिगत अदिश से बदलें", "कोई प्रतिस्थापन नहीं", "केवल ऐरे के लिए", "केवल संरचनाओं के लिए"],
    "answer_en": "Replace struct/array with individual scalars",
    "answer_hi": "संरचना/ऐरे को व्यक्तिगत अदिश से बदलें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 26,
    "question_en": "What is 'induction variable elimination'?",
    "question_hi": "'induction variable elimination' क्या है?",
    "options_en": ["Replace loop induction variable with simpler computation", "No elimination", "Only for constants", "Random replacement"],
    "options_hi": ["लूप प्रेरण चर को सरल गणना से बदलें", "कोई उन्मूलन नहीं", "केवल स्थिरांक के लिए", "यादृच्छिक प्रतिस्थापन"],
    "answer_en": "Replace loop induction variable with simpler computation",
    "answer_hi": "लूप प्रेरण चर को सरल गणना से बदलें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 27,
    "question_en": "What is 'loop versioning'?",
    "question_hi": "'loop versioning' क्या है?",
    "options_en": ["Create multiple loop versions for different runtime conditions", "Single version", "No versioning", "Only for bounds"],
    "options_hi": ["विभिन्न रनटाइम स्थितियों के लिए कई लूप संस्करण बनाएं", "एकल संस्करण", "कोई संस्करण नहीं", "केवल सीमाओं के लिए"],
    "answer_en": "Create multiple loop versions for different runtime conditions",
    "answer_hi": "विभिन्न रनटाइम स्थितियों के लिए कई लूप संस्करण बनाएं",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 28,
    "question_en": "What is 'loop unswitching'?",
    "question_hi": "'loop unswitching' क्या है?",
    "options_en": ["Move invariant conditional outside loop", "Keep inside", "No unswitching", "Only for simple if"],
    "options_hi": ["अपरिवर्तनीय सशर्त को लूप के बाहर ले जाएं", "अंदर रखें", "कोई अनस्विचिंग नहीं", "केवल सरल if के लिए"],
    "answer_en": "Move invariant conditional outside loop",
    "answer_hi": "अपरिवर्तनीय सशित को लूप के बाहर ले जाएं",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 29,
    "question_en": "What is 'loop peeling'?",
    "question_hi": "'loop peeling' क्या है?",
    "options_en": ["Execute first/last few iterations separately", "No peeling", "Only middle iterations", "Random peeling"],
    "options_hi": ["पहले/अंतिम कुछ पुनरावृत्तियों को अलग से निष्पादित करें", "कोई छीलना नहीं", "केवल मध्य पुनरावृत्तियाँ", "यादृच्छिक छीलना"],
    "answer_en": "Execute first/last few iterations separately",
    "answer_hi": "पहले/अंतिम कुछ पुनरावृत्तियों को अलग से निष्पादित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 30,
    "question_en": "What is 'loop skewing'?",
    "question_hi": "'loop skewing' क्या है?",
    "options_en": ["Transform loop to enable parallelization", "No transformation", "Only for dependency", "Random skew"],
    "options_hi": ["समानांतरकरण सक्षम करने के लिए लूप रूपांतरित करें", "कोई रूपांतरण नहीं", "केवल निर्भरता के लिए", "यादृच्छिक तिरछापन"],
    "answer_en": "Transform loop to enable parallelization",
    "answer_hi": "समानांतरकरण सक्षम करने के लिए लूप रूपांतरित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 31,
    "question_en": "What is 'software prefetching'?",
    "question_hi": "'software prefetching' क्या है?",
    "options_en": ["Insert prefetch instructions to hide memory latency", "No prefetch", "Hardware only", "Only for arrays"],
    "options_hi": ["मेमोरी विलंबता छिपाने के लिए प्रीफ़ेच निर्देश डालें", "कोई प्रीफ़ेच नहीं", "केवल हार्डवेयर", "केवल ऐरे के लिए"],
    "answer_en": "Insert prefetch instructions to hide memory latency",
    "answer_hi": "मेमोरी विलंबता छिपाने के लिए प्रीफ़ेच निर्देश डालें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 32,
    "question_en": "What is 'register pressure'?",
    "question_hi": "'register pressure' क्या है?",
    "options_en": ["High demand for registers causing spills", "Low demand", "No pressure", "Only for floats"],
    "options_hi": ["स्पिल्स का कारण बनने वाले रजिस्टरों की उच्च मांग", "कम मांग", "कोई दबाव नहीं", "केवल फ़्लोट्स के लिए"],
    "answer_en": "High demand for registers causing spills",
    "answer_hi": "स्पिल्स का कारण बनने वाले रजिस्टरों की उच्च मांग",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 33,
    "question_en": "What is 'instruction scheduling'?",
    "question_hi": "'instruction scheduling' क्या है?",
    "options_en": ["Reorder instructions to avoid pipeline stalls", "No reordering", "Random order", "Only for loads"],
    "options_hi": ["पाइपलाइन स्टाल से बचने के लिए निर्देशों को पुन: क्रमबद्ध करें", "कोई पुन: क्रमबद्धता नहीं", "यादृच्छिक क्रम", "केवल लोड के लिए"],
    "answer_en": "Reorder instructions to avoid pipeline stalls",
    "answer_hi": "पाइपलाइन स्टाल से बचने के लिए निर्देशों को पुन: क्रमबद्ध करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 34,
    "question_en": "What is 'software speculative load'?",
    "question_hi": "'software speculative load' क्या है?",
    "options_en": ["Load data before knowing if needed, check later", "No speculation", "Hardware only", "Only for branches"],
    "options_hi": ["आवश्यकता जानने से पहले डेटा लोड करें, बाद में जांचें", "कोई अटकल नहीं", "केवल हार्डवेयर", "केवल शाखाओं के लिए"],
    "answer_en": "Load data before knowing if needed, check later",
    "answer_hi": "आवश्यकता जानने से पहले डेटा लोड करें, बाद में जांचें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 35,
    "question_en": "What is 'pointer alignment analysis'?",
    "question_hi": "'pointer alignment analysis' क्या है?",
    "options_en": ["Determine if pointer is aligned for vector instructions", "No analysis", "Assume unaligned", "Only for malloc"],
    "options_hi": ["निर्धारित करें कि क्या पॉइंटर वेक्टर निर्देशों के लिए संरेखित है", "कोई विश्लेषण नहीं", "असंरेखित मान लें", "केवल malloc के लिए"],
    "answer_en": "Determine if pointer is aligned for vector instructions",
    "answer_hi": "निर्धारित करें कि क्या पॉइंटर वेक्टर निर्देशों के लिए संरेखित है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 36,
    "question_en": "What is 'automatic parallelization'?",
    "question_hi": "'automatic parallelization' क्या है?",
    "options_en": ["Compiler automatically generates parallel code", "No auto parallel", "Manual only", "Only for loops"],
    "options_hi": ["कंपाइलर स्वचालित रूप से समानांतर कोड उत्पन्न करता है", "कोई स्वचालित समानांतर नहीं", "केवल मैनुअल", "केवल लूप के लिए"],
    "answer_en": "Compiler automatically generates parallel code",
    "answer_hi": "कंपाइलर स्वचालित रूप से समानांतर कोड उत्पन्न करता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 37,
    "question_en": "What is 'polyhedral model' for loop optimization?",
    "question_hi": "लूप ऑप्टिमाइज़ेशन के लिए 'polyhedral model' क्या है?",
    "options_en": ["Mathematical model for loop transformations", "No model", "Simple model", "Only for nested loops"],
    "options_hi": ["लूप रूपांतरण के लिए गणितीय मॉडल", "कोई मॉडल नहीं", "सरल मॉडल", "केवल नेस्टेड लूप के लिए"],
    "answer_en": "Mathematical model for loop transformations",
    "answer_hi": "लूप रूपांतरण के लिए गणितीय मॉडल",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 38,
    "question_en": "What is 'data dependence analysis'?",
    "question_hi": "'data dependence analysis' क्या है?",
    "options_en": ["Determine if operations can be reordered", "No analysis", "Assume dependent", "Only for arrays"],
    "options_hi": ["निर्धारित करें कि संक्रियाओं को पुन: क्रमबद्ध किया जा सकता है", "कोई विश्लेषण नहीं", "निर्भर मान लें", "केवल ऐरे के लिए"],
    "answer_en": "Determine if operations can be reordered",
    "answer_hi": "निर्धारित करें कि संक्रियाओं को पुन: क्रमबद्ध किया जा सकता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 39,
    "question_en": "What is 'alias analysis' precision?",
    "question_hi": "'alias analysis' परिशुद्धता क्या है?",
    "options_en": ["Flow-sensitive, context-sensitive, field-sensitive", "No precision", "Always precise", "Only for pointers"],
    "options_hi": ["प्रवाह-संवेदनशील, संदर्भ-संवेदनशील, क्षेत्र-संवेदनशील", "कोई परिशुद्धता नहीं", "हमेशा सटीक", "केवल पॉइंटर्स के लिए"],
    "answer_en": "Flow-sensitive, context-sensitive, field-sensitive",
    "answer_hi": "प्रवाह-संवेदनशील, संदर्भ-संवेदनशील, क्षेत्र-संवेदनशील",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 40,
    "question_en": "What is 'escape analysis'?",
    "question_hi": "'escape analysis' क्या है?",
    "options_en": ["Determine if object escapes current scope", "No analysis", "Assume escapes", "Only for heap"],
    "options_hi": ["निर्धारित करें कि क्या ऑब्जेक्ट वर्तमान स्कोप से बच जाता है", "कोई विश्लेषण नहीं", "बच निकलना मान लें", "केवल हीप के लिए"],
    "answer_en": "Determine if object escapes current scope",
    "answer_hi": "निर्धारित करें कि क्या ऑब्जेक्ट वर्तमान स्कोप से बच जाता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 41,
    "question_en": "What is 'interprocedural constant propagation'?",
    "question_hi": "'interprocedural constant propagation' क्या है?",
    "options_en": ["Propagate constants across function calls", "Only intraprocedural", "No propagation", "Only for globals"],
    "options_hi": ["फ़ंक्शन कॉल में स्थिरांक प्रचारित करें", "केवल इंट्राप्रोसीजरल", "कोई प्रसार नहीं", "केवल ग्लोबल्स के लिए"],
    "answer_en": "Propagate constants across function calls",
    "answer_hi": "फ़ंक्शन कॉल में स्थिरांक प्रचारित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 42,
    "question_en": "What is 'devirtualization'?",
    "question_hi": "'devirtualization' क्या है?",
    "options_en": ["Replace virtual call with direct call if type known", "No replacement", "Always virtual", "Only C++"],
    "options_hi": ["यदि प्रकार ज्ञात है तो आभासी कॉल को प्रत्यक्ष कॉल से बदलें", "कोई प्रतिस्थापन नहीं", "हमेशा आभासी", "केवल C++"],
    "answer_en": "Replace virtual call with direct call if type known",
    "answer_hi": "यदि प्रकार ज्ञात है तो आभासी कॉल को प्रत्यक्ष कॉल से बदलें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 43,
    "question_en": "What is 'stack slot sharing'?",
    "question_hi": "'stack slot sharing' क्या है?",
    "options_en": ["Reuse same stack slot for non-overlapping variables", "No sharing", "Separate slots", "Only for temps"],
    "options_hi": ["गैर-ओवरलैपिंग वेरिएबल्स के लिए एक ही स्टैक स्लॉट का पुन: उपयोग", "कोई साझाकरण नहीं", "अलग स्लॉट", "केवल टेम्प्स के लिए"],
    "answer_en": "Reuse same stack slot for non-overlapping variables",
    "answer_hi": "गैर-ओवरलैपिंग वेरिएबल्स के लिए एक ही स्टैक स्लॉट का पुन: उपयोग",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 44,
    "question_en": "What is 'tail duplication'?",
    "question_hi": "'tail duplication' क्या है?",
    "options_en": ["Duplicate tail of basic block to enable optimization", "No duplication", "Only head", "Random duplication"],
    "options_hi": ["ऑप्टिमाइज़ेशन सक्षम करने के लिए बेसिक ब्लॉक की टेल डुप्लिकेट करें", "कोई डुप्लिकेशन नहीं", "केवल हेड", "यादृच्छिक डुप्लिकेशन"],
    "answer_en": "Duplicate tail of basic block to enable optimization",
    "answer_hi": "ऑप्टिमाइज़ेशन सक्षम करने के लिए बेसिक ब्लॉक की टेल डुप्लिकेट करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 45,
    "question_en": "What is 'jump threading'?",
    "question_hi": "'jump threading' क्या है?",
    "options_en": ["Redirect jump through intermediate jumps", "No threading", "Only direct jumps", "Random redirect"],
    "options_hi": ["मध्यवर्ती जंप के माध्यम से जंप रीडायरेक्ट करें", "कोई थ्रेडिंग नहीं", "केवल प्रत्यक्ष जंप", "यादृच्छिक रीडायरेक्ट"],
    "answer_en": "Redirect jump through intermediate jumps",
    "answer_hi": "मध्यवर्ती जंप के माध्यम से जंप रीडायरेक्ट करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 46,
    "question_en": "What is 'basic block reordering'?",
    "question_hi": "'basic block reordering' क्या है?",
    "options_en": ["Reorder blocks to improve cache locality", "No reordering", "Random order", "Only for hot paths"],
    "options_hi": ["कैश स्थानीयता में सुधार के लिए ब्लॉकों को पुन: क्रमबद्ध करें", "कोई पुन: क्रमबद्धता नहीं", "यादृच्छिक क्रम", "केवल हॉट पथ के लिए"],
    "answer_en": "Reorder blocks to improve cache locality",
    "answer_hi": "कैश स्थानीयता में सुधार के लिए ब्लॉकों को पुन: क्रमबद्ध करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 47,
    "question_en": "What is 'function splitting'?",
    "question_hi": "'function splitting' क्या है?",
    "options_en": ["Split function into hot/cold parts", "No splitting", "Only merge", "Random split"],
    "options_hi": ["फ़ंक्शन को हॉट/कोल्ड भागों में विभाजित करें", "कोई विभाजन नहीं", "केवल विलय", "यादृच्छिक विभाजन"],
    "answer_en": "Split function into hot/cold parts",
    "answer_hi": "फ़ंक्शन को हॉट/कोल्ड भागों में विभाजित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 48,
    "question_en": "What is 'out-of-SSA' conversion?",
    "question_hi": "'out-of-SSA' रूपांतरण क्या है?",
    "options_en": ["Convert from SSA form to executable code", "No conversion", "Only to SSA", "Random conversion"],
    "options_hi": ["SSA फॉर्म से निष्पादन योग्य कोड में बदलें", "कोई रूपांतरण नहीं", "केवल SSA में", "यादृच्छिक रूपांतरण"],
    "answer_en": "Convert from SSA form to executable code",
    "answer_hi": "SSA फॉर्म से निष्पादन योग्य कोड में बदलें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 49,
    "question_en": "What is 'phi node' in SSA?",
    "question_hi": "SSA में 'phi node' क्या है?",
    "options_en": ["Φ function selecting value based on incoming edge", "No phi", "Only for loops", "Random selection"],
    "options_hi": ["Φ फ़ंक्शन आने वाले किनारे के आधार पर मान चुनता है", "कोई phi नहीं", "केवल लूप के लिए", "यादृच्छिक चयन"],
    "answer_en": "Φ function selecting value based on incoming edge",
    "answer_hi": "Φ फ़ंक्शन आने वाले किनारे के आधार पर मान चुनता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 50,
    "question_en": "What is 'live range splitting'?",
    "question_hi": "'live range splitting' क्या है?",
    "options_en": ["Split variable's live range to reduce register pressure", "No splitting", "Only merge", "Random split"],
    "options_hi": ["रजिस्टर दबाव कम करने के लिए वेरिएबल की लाइव रेंज विभाजित करें", "कोई विभाजन नहीं", "केवल विलय", "यादृच्छिक विभाजन"],
    "answer_en": "Split variable's live range to reduce register pressure",
    "answer_hi": "रजिस्टर दबाव कम करने के लिए वेरिएबल की लाइव रेंज विभाजित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 51,
    "question_en": "What is 'graph coloring register allocation'?",
    "question_hi": "'graph coloring register allocation' क्या है?",
    "options_en": ["Model interference as graph, color with registers", "No graph", "Linear scan", "Random allocation"],
    "options_hi": ["हस्तक्षेप को ग्राफ के रूप में मॉडल करें, रजिस्टरों के साथ रंग भरें", "कोई ग्राफ नहीं", "रैखिक स्कैन", "यादृच्छिक आवंटन"],
    "answer_en": "Model interference as graph, color with registers",
    "answer_hi": "हस्तक्षेप को ग्राफ के रूप में मॉडल करें, रजिस्टरों के साथ रंग भरें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 52,
    "question_en": "What is 'linear scan register allocation'?",
    "question_hi": "'linear scan register allocation' क्या है?",
    "options_en": ["Faster allocation by scanning live intervals linearly", "No scan", "Graph coloring", "Random allocation"],
    "options_hi": ["लाइव अंतराल को रैखिक रूप से स्कैन करके तेज आवंटन", "कोई स्कैन नहीं", "ग्राफ रंगाई", "यादृच्छिक आवंटन"],
    "answer_en": "Faster allocation by scanning live intervals linearly",
    "answer_hi": "लाइव अंतराल को रैखिक रूप से स्कैन करके तेज आवंटन",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 53,
    "question_en": "What is 'spill code'?",
    "question_hi": "'spill code' क्या है?",
    "options_en": ["Load/store instructions for spilled variables", "No spill", "Only load", "Only store"],
    "options_hi": ["स्पिल किए गए वेरिएबल्स के लिए लोड/स्टोर निर्देश", "कोई स्पिल नहीं", "केवल लोड", "केवल स्टोर"],
    "answer_en": "Load/store instructions for spilled variables",
    "answer_hi": "स्पिल किए गए वेरिएबल्स के लिए लोड/स्टोर निर्देश",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 54,
    "question_en": "What is 'rematerialization'?",
    "question_hi": "'rematerialization' क्या है?",
    "options_en": ["Recompute value instead of spilling/reloading", "No recompute", "Always spill", "Random choice"],
    "options_hi": ["स्पिल/रीलोड करने के बजाय मान की पुनर्गणना करें", "कोई पुनर्गणना नहीं", "हमेशा स्पिल", "यादृच्छिक चयन"],
    "answer_en": "Recompute value instead of spilling/reloading",
    "answer_hi": "स्पिल/रीलोड करने के बजाय मान की पुनर्गणना करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 55,
    "question_en": "What is 'coalescing' in register allocation?",
    "question_hi": "रजिस्टर आवंटन में 'coalescing' क्या है?",
    "options_en": ["Merge move-related variables to same register", "No merging", "Separate always", "Random merge"],
    "options_hi": ["मूव-संबंधित वेरिएबल्स को एक ही रजिस्टर में मर्ज करें", "कोई विलय नहीं", "हमेशा अलग", "यादृच्छिक विलय"],
    "answer_en": "Merge move-related variables to same register",
    "answer_hi": "मूव-संबंधित वेरिएबल्स को एक ही रजिस्टर में मर्ज करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 56,
    "question_en": "What is 'live variable analysis'?",
    "question_hi": "'live variable analysis' क्या है?",
    "options_en": ["Determine which variables are live at each point", "No analysis", "Assume all live", "Only for registers"],
    "options_hi": ["निर्धारित करें कि कौन से वेरिएबल्स प्रत्येक बिंदु पर लाइव हैं", "कोई विश्लेषण नहीं", "सभी लाइव मान लें", "केवल रजिस्टरों के लिए"],
    "answer_en": "Determine which variables are live at each point",
    "answer_hi": "निर्धारित करें कि कौन से वेरिएबल्स प्रत्येक बिंदु पर लाइव हैं",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 57,
    "question_en": "What is 'def-use chain'?",
    "question_hi": "'def-use chain' क्या है?",
    "options_en": ["Links definition to uses of variable", "No chain", "Only def", "Only use"],
    "options_hi": ["परिभाषा को वेरिएबल के उपयोगों से जोड़ता है", "कोई श्रृंखला नहीं", "केवल def", "केवल use"],
    "answer_en": "Links definition to uses of variable",
    "answer_hi": "परिभाषा को वेरिएबल के उपयोगों से जोड़ता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 58,
    "question_en": "What is 'dominance frontier'?",
    "question_hi": "'dominance frontier' क्या है?",
    "options_en": ["Set of nodes just outside dominated region (for SSA)", "No frontier", "Inside region", "Random set"],
    "options_hi": ["प्रभुत्व वाले क्षेत्र के बाहर के नोड्स का सेट (SSA के लिए)", "कोई सीमा नहीं", "क्षेत्र के अंदर", "यादृच्छिक सेट"],
    "answer_en": "Set of nodes just outside dominated region (for SSA)",
    "answer_hi": "प्रभुत्व वाले क्षेत्र के बाहर के नोड्स का सेट (SSA के लिए)",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 59,
    "question_en": "What is 'control dependence'?",
    "question_hi": "'control dependence' क्या है?",
    "options_en": ["Statement execution depends on branch outcome", "No dependence", "Data dependence", "Random dependence"],
    "options_hi": ["कथन निष्पादन शाखा परिणाम पर निर्भर करता है", "कोई निर्भरता नहीं", "डेटा निर्भरता", "यादृच्छिक निर्भरता"],
    "answer_en": "Statement execution depends on branch outcome",
    "answer_hi": "कथन निष्पादन शाखा परिणाम पर निर्भर करता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 60,
    "question_en": "What is 'post-dominance'?",
    "question_hi": "'post-dominance' क्या है?",
    "options_en": ["Node A post-dominates B if all paths from B to exit go through A", "No post-dom", "Reverse dominance", "Random"],
    "options_hi": ["नोड A B को पोस्ट-डोमिनेट करता है यदि B से निकास तक के सभी पथ A से होकर गुजरते हैं", "कोई पोस्ट-डोम नहीं", "रिवर्स डोमिनेंस", "यादृच्छिक"],
    "answer_en": "Node A post-dominates B if all paths from B to exit go through A",
    "answer_hi": "नोड A B को पोस्ट-डोमिनेट करता है यदि B से निकास तक के सभी पथ A से होकर गुजरते हैं",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 61,
    "question_en": "What is 'natural loop' identification?",
    "question_hi": "'natural loop' पहचान क्या है?",
    "options_en": ["Loop with single entry point (header)", "Multiple entry", "No entry", "Random loop"],
    "options_hi": ["एकल प्रवेश बिंदु (हेडर) वाला लूप", "एकाधिक प्रवेश", "कोई प्रवेश नहीं", "यादृच्छिक लूप"],
    "answer_en": "Loop with single entry point (header)",
    "answer_hi": "एकल प्रवेश बिंदु (हेडर) वाला लूप",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 62,
    "question_en": "What is 'reducible flow graph'?",
    "question_hi": "'reducible flow graph' क्या है?",
    "options_en": ["CFG that can be decomposed into natural loops", "Irreducible", "No loops", "Random graph"],
    "options_hi": ["CFG जिसे प्राकृतिक लूप में विघटित किया जा सकता है", "अपूरणीय", "कोई लूप नहीं", "यादृच्छिक ग्राफ"],
    "answer_en": "CFG that can be decomposed into natural loops",
    "answer_hi": "CFG जिसे प्राकृतिक लूप में विघटित किया जा सकता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 63,
    "question_en": "What is 'interval analysis'?",
    "question_hi": "'interval analysis' क्या है?",
    "options_en": ["Determine possible value ranges for variables", "No analysis", "Only constants", "Random ranges"],
    "options_hi": ["वेरिएबल्स के लिए संभावित मान सीमा निर्धारित करें", "कोई विश्लेषण नहीं", "केवल स्थिरांक", "यादृच्छिक सीमाएँ"],
    "answer_en": "Determine possible value ranges for variables",
    "answer_hi": "वेरिएबल्स के लिए संभावित मान सीमा निर्धारित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 64,
    "question_en": "What is 'abstract interpretation'?",
    "question_hi": "'abstract interpretation' क्या है?",
    "options_en": ["Static analysis using abstract domains", "No abstraction", "Concrete only", "Random interpretation"],
    "options_hi": ["अमूर्त डोमेन का उपयोग कर स्थैतिक विश्लेषण", "कोई अमूर्तता नहीं", "केवल ठोस", "यादृच्छिक व्याख्या"],
    "answer_en": "Static analysis using abstract domains",
    "answer_hi": "अमूर्त डोमेन का उपयोग कर स्थैतिक विश्लेषण",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 65,
    "question_en": "What is 'symbolic execution'?",
    "question_hi": "'symbolic execution' क्या है?",
    "options_en": ["Execute with symbolic values instead of concrete", "No symbolic", "Only concrete", "Random execution"],
    "options_hi": ["ठोस के बजाय प्रतीकात्मक मूल्यों के साथ निष्पादित करें", "कोई प्रतीकात्मक नहीं", "केवल ठोस", "यादृच्छिक निष्पादन"],
    "answer_en": "Execute with symbolic values instead of concrete",
    "answer_hi": "ठोस के बजाय प्रतीकात्मक मूल्यों के साथ निष्पादित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 66,
    "question_en": "What is 'concolic execution'?",
    "question_hi": "'concolic execution' क्या है?",
    "options_en": ["Combination of concrete and symbolic execution", "No combination", "Only symbolic", "Only concrete"],
    "options_hi": ["ठोस और प्रतीकात्मक निष्पादन का संयोजन", "कोई संयोजन नहीं", "केवल प्रतीकात्मक", "केवल ठोस"],
    "answer_en": "Combination of concrete and symbolic execution",
    "answer_hi": "ठोस और प्रतीकात्मक निष्पादन का संयोजन",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 67,
    "question_en": "What is 'fuzz testing' for C programs?",
    "question_hi": "C प्रोग्राम के लिए 'fuzz testing' क्या है?",
    "options_en": ["Automated testing with random/mutated inputs", "No fuzzing", "Only unit tests", "Manual testing"],
    "options_hi": ["यादृच्छिक/उत्परिवर्तित इनपुट के साथ स्वचालित परीक्षण", "कोई फजिंग नहीं", "केवल यूनिट टेस्ट", "मैन्युअल परीक्षण"],
    "answer_en": "Automated testing with random/mutated inputs",
    "answer_hi": "यादृच्छिक/उत्परिवर्तित इनपुट के साथ स्वचालित परीक्षण",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 68,
    "question_en": "What is 'sanitizer' (e.g., AddressSanitizer)?",
    "question_hi": "'sanitizer' (जैसे, AddressSanitizer) क्या है?",
    "options_en": ["Runtime memory error detector", "No detection", "Static only", "Compiler only"],
    "options_hi": ["रनटाइम मेमोरी त्रुटि डिटेक्टर", "कोई पता लगाना नहीं", "केवल स्थैतिक", "केवल कंपाइलर"],
    "answer_en": "Runtime memory error detector",
    "answer_hi": "रनटाइम मेमोरी त्रुटि डिटेक्टर",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 69,
    "question_en": "What is 'undefined behavior sanitizer' (UBSan)?",
    "question_hi": "'undefined behavior sanitizer' (UBSan) क्या है?",
    "options_en": ["Detects undefined behavior at runtime", "No detection", "Only memory errors", "Only compile time"],
    "options_hi": ["रनटाइम पर अपरिभाषित व्यवहार का पता लगाता है", "कोई पता लगाना नहीं", "केवल मेमोरी त्रुटियाँ", "केवल संकलन समय"],
    "answer_en": "Detects undefined behavior at runtime",
    "answer_hi": "रनटाइम पर अपरिभाषित व्यवहार का पता लगाता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 70,
    "question_en": "What is 'ThreadSanitizer' (TSan)?",
    "question_hi": "'ThreadSanitizer' (TSan) क्या है?",
    "options_en": ["Detects data races", "No race detection", "Only deadlocks", "Only memory errors"],
    "options_hi": ["डेटा रेस का पता लगाता है", "कोई रेस पता लगाना नहीं", "केवल डेडलॉक्स", "केवल मेमोरी त्रुटियाँ"],
    "answer_en": "Detects data races",
    "answer_hi": "डेटा रेस का पता लगाता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 71,
    "question_en": "What is 'MemorySanitizer' (MSan)?",
    "question_hi": "'MemorySanitizer' (MSan) क्या है?",
    "options_en": ["Detects uninitialized memory reads", "No detection", "Only leaks", "Only overflows"],
    "options_hi": ["अप्रारंभिक मेमोरी रीड का पता लगाता है", "कोई पता लगाना नहीं", "केवल रिसाव", "केवल ओवरफ्लो"],
    "answer_en": "Detects uninitialized memory reads",
    "answer_hi": "अप्रारंभिक मेमोरी रीड का पता लगाता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 72,
    "question_en": "What is 'LeakSanitizer' (LSan)?",
    "question_hi": "'LeakSanitizer' (LSan) क्या है?",
    "options_en": ["Detects memory leaks", "No leak detection", "Only use-after-free", "Only buffer overflow"],
    "options_hi": ["मेमोरी लीक का पता लगाता है", "कोई लीक पता लगाना नहीं", "केवल उपयोग-के-बाद-मुक्त", "केवल बफर ओवरफ्लो"],
    "answer_en": "Detects memory leaks",
    "answer_hi": "मेमोरी लीक का पता लगाता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 73,
    "question_en": "What is 'hardware transactional memory' support in C?",
    "question_hi": "C में 'hardware transactional memory' समर्थन क्या है?",
    "options_en": "Not in C standard; compiler extensions (e.g., __tm_atomic)",
    "question_hi": "C मानक में नहीं; कंपाइलर एक्सटेंशन (जैसे, __tm_atomic)",
    "options_en": ["Compiler-specific extensions", "Standard feature", "No support", "Only in C++"],
    "options_hi": ["कंपाइलर-विशिष्ट एक्सटेंशन", "मानक सुविधा", "कोई समर्थन नहीं", "केवल C++ में"],
    "answer_en": "Compiler-specific extensions",
    "answer_hi": "कंपाइलर-विशिष्ट एक्सटेंशन",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 74,
    "question_en": "What is 'cache oblivious algorithm' implementation in C?",
    "question_hi": "C में 'cache oblivious algorithm' कार्यान्वयन क्या है?",
    "options_en": ["Algorithm performs well regardless of cache hierarchy", "Cache aware", "No cache consideration", "Only for large data"],
    "options_hi": ["एल्गोरिथ्म कैच पदानुक्रम की परवाह किए बिना अच्छा प्रदर्शन करता है", "कैच अवेयर", "कोई कैच विचार नहीं", "केवल बड़े डेटा के लिए"],
    "answer_en": "Algorithm performs well regardless of cache hierarchy",
    "answer_hi": "एल्गोरिथ्म कैच पदानुक्रम की परवाह किए बिना अच्छा प्रदर्शन करता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 75,
    "question_en": "What is 'speculative side channel mitigation' in C?",
    "question_hi": "C में 'speculative side channel mitigation' क्या है?",
    "options_en": ["Use serializing instructions or fences", "No mitigation", "Only for crypto", "Compiler automatic"],
    "options_hi": ["सीरियलाइज़िंग निर्देश या बाड़ का उपयोग करें", "कोई शमन नहीं", "केवल क्रिप्टो के लिए", "कंपाइलर स्वचालित"],
    "answer_en": "Use serializing instructions or fences",
    "answer_hi": "सीरियलाइज़िंग निर्देश या बाड़ का उपयोग करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 76,
    "question_en": "What is 'constant time programming' for crypto in C?",
    "question_hi": "C में क्रिप्टो के लिए 'constant time programming' क्या है?",
    "options_en": ["Avoid branches/accesses depending on secret data", "Use branches", "No special care", "Only for public data"],
    "options_hi": ["गुप्त डेटा पर निर्भर शाखाओं/एक्सेस से बचें", "शाखाओं का उपयोग करें", "कोई विशेष देखभाल नहीं", "केवल सार्वजनिक डेटा के लिए"],
    "answer_en": "Avoid branches/accesses depending on secret data",
    "answer_hi": "गुप्त डेटा पर निर्भर शाखाओं/एक्सेस से बचें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 77,
    "question_en": "What is 'restrict' and loop vectorization?",
    "question_hi": "'restrict' और लूप वेक्टराइजेशन क्या है?",
    "options_en": ["restrict helps compiler vectorize loops (no aliasing)", "No help", "Hinders", "Only for pointers"],
    "options_hi": ["restrict कंपाइलर को लूप वेक्टराइज करने में मदद करता है (कोई एलियासिंग नहीं)", "कोई मदद नहीं", "बाधा डालता है", "केवल पॉइंटर्स के लिए"],
    "answer_en": "restrict helps compiler vectorize loops (no aliasing)",
    "answer_hi": "restrict कंपाइलर को लूप वेक्टराइज करने में मदद करता है (कोई एलियासिंग नहीं)",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 78,
    "question_en": "What is 'SIMD intrinsic' manual vectorization?",
    "question_hi": "'SIMD intrinsic' मैनुअल वेक्टराइजेशन क्या है?",
    "options_en": ["Using compiler intrinsics (e.g., _mm_add_ps) for SIMD", "Automatic only", "No SIMD", "Only for floats"],
    "options_hi": ["SIMD के लिए कंपाइलर इन्ट्रिंसिक्स (जैसे, _mm_add_ps) का उपयोग", "केवल स्वचालित", "कोई SIMD नहीं", "केवल फ़्लोट्स के लिए"],
    "answer_en": "Using compiler intrinsics (e.g., _mm_add_ps) for SIMD",
    "answer_hi": "SIMD के लिए कंपाइलर इन्ट्रिंसिक्स (जैसे, _mm_add_ps) का उपयोग",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 79,
    "question_en": "What is 'auto-vectorization report' in compiler?",
    "question_hi": "कंपाइलर में 'auto-vectorization report' क्या है?",
    "options_en": ["Compiler output showing which loops vectorized", "No report", "Only errors", "Only for failed"],
    "options_hi": ["कंपाइलर आउटपुट दिखाता है कि कौन से लूप वेक्टराइज हुए", "कोई रिपोर्ट नहीं", "केवल त्रुटियाँ", "केवल विफल के लिए"],
    "answer_en": "Compiler output showing which loops vectorized",
    "answer_hi": "कंपाइलर आउटपुट दिखाता है कि कौन से लूप वेक्टराइज हुए",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 80,
    "question_en": "What is 'loop nest optimization'?",
    "question_hi": "'loop nest optimization' क्या है?",
    "options_en": ["Optimizations for multi-dimensional loops", "Only 1D loops", "No nest optimization", "Random optimization"],
    "options_hi": ["बहुआयामी लूप के लिए ऑप्टिमाइज़ेशन", "केवल 1D लूप", "कोई नेस्ट ऑप्टिमाइज़ेशन नहीं", "यादृच्छिक ऑप्टिमाइज़ेशन"],
    "answer_en": "Optimizations for multi-dimensional loops",
    "answer_hi": "बहुआयामी लूप के लिए ऑप्टिमाइज़ेशन",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 81,
    "question_en": "What is 'iteration space slicing'?",
    "question_hi": "'iteration space slicing' क्या है?",
    "options_en": ["Divide iteration space for parallel execution", "No division", "Only sequential", "Random division"],
    "options_hi": ["समानांतर निष्पादन के लिए पुनरावृत्ति स्थान विभाजित करें", "कोई विभाजन नहीं", "केवल अनुक्रमिक", "यादृच्छिक विभाजन"],
    "answer_en": "Divide iteration space for parallel execution",
    "answer_hi": "समानांतर निष्पादन के लिए पुनरावृत्ति स्थान विभाजित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 82,
    "question_en": "What is 'dependence distance vector'?",
    "question_hi": "'dependence distance vector' क्या है?",
    "options_en": ["Vector showing distance between dependent iterations", "No vector", "Only scalar distance", "Random vector"],
    "options_hi": ["वेक्टर निर्भर पुनरावृत्तियों के बीच दूरी दिखाता है", "कोई वेक्टर नहीं", "केवल अदिश दूरी", "यादृच्छिक वेक्टर"],
    "answer_en": "Vector showing distance between dependent iterations",
    "answer_hi": "वेक्टर निर्भर पुनरावृत्तियों के बीच दूरी दिखाता है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 83,
    "question_en": "What is 'loop-carried dependence'?",
    "question_hi": "'loop-carried dependence' क्या है?",
    "options_en": ["Dependence across loop iterations", "Within same iteration", "No dependence", "Random dependence"],
    "options_hi": ["लूप पुनरावृत्तियों में निर्भरता", "एक ही पुनरावृत्ति के भीतर", "कोई निर्भरता नहीं", "यादृच्छिक निर्भरता"],
    "answer_en": "Dependence across loop iterations",
    "answer_hi": "लूप पुनरावृत्तियों में निर्भरता",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 84,
    "question_en": "What is 'reduction variable recognition'?",
    "question_hi": "'reduction variable recognition' क्या है?",
    "options_en": ["Identify variables updated with associative operation", "No recognition", "Only for arrays", "Random recognition"],
    "options_hi": ["साहचर्य संक्रिया के साथ अद्यतन वेरिएबल्स की पहचान करें", "कोई पहचान नहीं", "केवल ऐरे के लिए", "यादृच्छिक पहचान"],
    "answer_en": "Identify variables updated with associative operation",
    "answer_hi": "साहचर्य संक्रिया के साथ अद्यतन वेरिएबल्स की पहचान करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 85,
    "question_en": "What is 'induction variable recognition'?",
    "question_hi": "'induction variable recognition' क्या है?",
    "options_en": ["Identify variables changing by constant each iteration", "No recognition", "Only for loops", "Random recognition"],
    "options_hi": ["प्रत्येक पुनरावृत्ति में स्थिरांक से बदलने वाले वेरिएबल्स की पहचान करें", "कोई पहचान नहीं", "केवल लूप के लिए", "यादृच्छिक पहचान"],
    "answer_en": "Identify variables changing by constant each iteration",
    "answer_hi": "प्रत्येक पुनरावृत्ति में स्थिरांक से बदलने वाले वेरिएबल्स की पहचान करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 86,
    "question_en": "What is 'scalar evolution analysis'?",
    "question_hi": "'scalar evolution analysis' क्या है?",
    "options_en": ["Analyze how scalars evolve through loops", "No analysis", "Only for arrays", "Random analysis"],
    "options_hi": ["विश्लेषण करें कि अदिश लूप के माध्यम से कैसे विकसित होते हैं", "कोई विश्लेषण नहीं", "केवल ऐरे के लिए", "यादृच्छिक विश्लेषण"],
    "answer_en": "Analyze how scalars evolve through loops",
    "answer_hi": "विश्लेषण करें कि अदिश लूप के माध्यम से कैसे विकसित होते हैं",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 87,
    "question_en": "What is 'chunking' in parallel loops?",
    "question_hi": "समानांतर लूप में 'chunking' क्या है?",
    "options_en": ["Divide iterations into chunks for load balancing", "No chunking", "Equal chunks only", "Random chunks"],
    "options_hi": ["लोड बैलेंसिंग के लिए पुनरावृत्तियों को चंक्स में विभाजित करें", "कोई चंकिंग नहीं", "केवल समान चंक", "यादृच्छिक चंक"],
    "answer_en": "Divide iterations into chunks for load balancing",
    "answer_hi": "लोड बैलेंसिंग के लिए पुनरावृत्तियों को चंक्स में विभाजित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 88,
    "question_en": "What is 'loop collapse' (OpenMP style)?",
    "question_hi": "'loop collapse' (OpenMP शैली) क्या है?",
    "options_en": ["Collapse nested loops into single iteration space", "No collapse", "Only 2 loops", "Random collapse"],
    "options_hi": ["नेस्टेड लूप को एकल पुनरावृत्ति स्थान में संक्षिप्त करें", "कोई संक्षिप्त नहीं", "केवल 2 लूप", "यादृच्छिक संक्षिप्त"],
    "answer_en": "Collapse nested loops into single iteration space",
    "answer_hi": "नेस्टेड लूप को एकल पुनरावृत्ति स्थान में संक्षिप्त करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 89,
    "question_en": "What is 'software cache' for GPU in C?",
    "question_hi": "C में GPU के लिए 'software cache' क्या है?",
    "options_en": ["Manual caching in shared/local memory", "No software cache", "Hardware only", "Only for CPU"],
    "options_hi": ["साझा/स्थानीय मेमोरी में मैनुअल कैशिंग", "कोई सॉफ़्टवेयर कैश नहीं", "केवल हार्डवेयर", "केवल CPU के लिए"],
    "answer_en": "Manual caching in shared/local memory",
    "answer_hi": "साझा/स्थानीय मेमोरी में मैनुअल कैशिंग",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 90,
    "question_en": "What is 'bank conflict' avoidance in GPU programming?",
    "question_hi": "GPU प्रोग्रामिंग में 'bank conflict' परिहार क्या है?",
    "options_en": ["Arrange memory accesses to avoid shared memory bank conflicts", "No avoidance", "Ignore conflicts", "Only for global memory"],
    "options_hi": ["साझा मेमोरी बैंक संघर्ष से बचने के लिए मेमोरी एक्सेस व्यवस्थित करें", "कोई परिहार नहीं", "संघर्षों को नजरअंदाज करें", "केवल वैश्विक मेमोरी के लिए"],
    "answer_en": "Arrange memory accesses to avoid shared memory bank conflicts",
    "answer_hi": "साझा मेमोरी बैंक संघर्ष से बचने के लिए मेमोरी एक्सेस व्यवस्थित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 91,
    "question_en": "What is 'warp divergence' minimization?",
    "question_hi": "'warp divergence' न्यूनीकरण क्या है?",
    "options_en": ["Minimize conditional branches within warp", "No minimization", "Encourage divergence", "Only for small warps"],
    "options_hi": ["वार्प के भीतर सशित शाखाओं को कम से कम करें", "कोई न्यूनीकरण नहीं", "विचलन को प्रोत्साहित करें", "केवल छोटे वार्प के लिए"],
    "answer_en": "Minimize conditional branches within warp",
    "answer_hi": "वार्प के भीतर सशित शाखाओं को कम से कम करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 92,
    "question_en": "What is 'occupancy' in GPU programming?",
    "question_hi": "GPU प्रोग्रामिंग में 'occupancy' क्या है?",
    "options_en": ["Ratio of active warps to maximum supported", "No occupancy", "Only threads", "Random ratio"],
    "options_hi": ["सक्रिय वार्प का अधिकतम समर्थित से अनुपात", "कोई अधिभोग नहीं", "केवल थ्रेड्स", "यादृच्छिक अनुपात"],
    "answer_en": "Ratio of active warps to maximum supported",
    "answer_hi": "सक्रिय वार्प का अधिकतम समर्थित से अनुपात",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 93,
    "question_en": "What is 'register spilling' on GPU?",
    "question_hi": "GPU पर 'register spilling' क्या है?",
    "options_en": ["Excess registers causing spilling to local memory", "No spilling", "Only cache", "Only for CPU"],
    "options_hi": ["अतिरिक्त रजिस्टर स्थानीय मेमोरी में स्पिलिंग का कारण बनते हैं", "कोई स्पिलिंग नहीं", "केवल कैश", "केवल CPU के लिए"],
    "answer_en": "Excess registers causing spilling to local memory",
    "answer_hi": "अतिरिक्त रजिस्टर स्थानीय मेमोरी में स्पिलिंग का कारण बनते हैं",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 94,
    "question_en": "What is 'memory coalescing' on GPU?",
    "question_hi": "GPU पर 'memory coalescing' क्या है?",
    "options_en": ["Combine memory accesses of consecutive threads into single transaction", "No coalescing", "Separate accesses", "Only for shared memory"],
    "options_hi": ["लगातार थ्रेड्स की मेमोरी एक्सेस को एकल लेनदेन में संयोजित करें", "कोई समेकन नहीं", "अलग एक्सेस", "केवल साझा मेमोरी के लिए"],
    "answer_en": "Combine memory accesses of consecutive threads into single transaction",
    "answer_hi": "लगातार थ्रेड्स की मेमोरी एक्सेस को एकल लेनदेन में संयोजित करें",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 95,
    "question_en": "What is 'zero-copy memory' in CUDA/OpenCL?",
    "question_hi": "CUDA/OpenCL में 'zero-copy memory' क्या है?",
    "options_en": ["CPU-GPU shared memory avoiding explicit copy", "Copy required", "No shared memory", "Only for small data"],
    "options_hi": ["स्पष्ट कॉपी से बचने वाली CPU-GPU साझा मेमोरी", "कॉपी आवश्यक", "कोई साझा मेमोरी नहीं", "केवल छोटे डेटा के लिए"],
    "answer_en": "CPU-GPU shared memory avoiding explicit copy",
    "answer_hi": "स्पष्ट कॉपी से बचने वाली CPU-GPU साझा मेमोरी",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 96,
    "question_en": "What is 'pinned memory' for GPU transfers?",
    "question_hi": "GPU स्थानांतरण के लिए 'pinned memory' क्या है?",
    "options_en": ["Page-locked host memory for faster DMA transfers", "Regular memory", "No speedup", "Only for GPU memory"],
    "options_hi": ["तेज़ DMA स्थानांतरण के लिए पेज-लॉक्ड होस्ट मेमोरी", "नियमित मेमोरी", "कोई स्पीडअप नहीं", "केवल GPU मेमोरी के लिए"],
    "answer_en": "Page-locked host memory for faster DMA transfers",
    "answer_hi": "तेज़ DMA स्थानांतरण के लिए पेज-लॉक्ड होस्ट मेमोरी",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 97,
    "question_en": "What is 'stream' in GPU programming?",
    "question_hi": "GPU प्रोग्रामिंग में 'stream' क्या है?",
    "options_en": ["Sequence of operations executed in order, concurrent with other streams", "No concurrency", "Only one stream", "Random order"],
    "options_hi": ["अन्य स्ट्रीम के साथ समवर्ती रूप से क्रम में निष्पादित संक्रियाओं का क्रम", "कोई समवर्तिता नहीं", "केवल एक स्ट्रीम", "यादृच्छिक क्रम"],
    "answer_en": "Sequence of operations executed in order, concurrent with other streams",
    "answer_hi": "अन्य स्ट्रीम के साथ समवर्ती रूप से क्रम में निष्पादित संक्रियाओं का क्रम",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 98,
    "question_en": "What is 'kernel launch overhead'?",
    "question_hi": "'kernel launch overhead' क्या है?",
    "options_en": ["Time to start GPU kernel (independent of work size)", "No overhead", "Depends on work", "Only for small kernels"],
    "options_hi": ["GPU कर्नेल शुरू करने का समय (कार्य आकार से स्वतंत्र)", "कोई ओवरहेड नहीं", "कार्य पर निर्भर", "केवल छोटे कर्नेल के लिए"],
    "answer_en": "Time to start GPU kernel (independent of work size)",
    "answer_hi": "GPU कर्नेल शुरू करने का समय (कार्य आकार से स्वतंत्र)",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 99,
    "question_en": "What is 'dynamic parallelism' in GPU?",
    "question_hi": "GPU में 'dynamic parallelism' क्या है?",
    "options_en": ["GPU kernel launching another kernel", "No nested launch", "CPU only", "Only for specific GPUs"],
    "options_hi": ["GPU कर्नेल दूसरा कर्नेल लॉन्च कर रहा है", "कोई नेस्टेड लॉन्च नहीं", "केवल CPU", "केवल विशिष्ट GPU के लिए"],
    "answer_en": "GPU kernel launching another kernel",
    "answer_hi": "GPU कर्नेल दूसरा कर्नेल लॉन्च कर रहा है",
    "attempted": false,
    "selected": ""
  },
  {
    "num": 100,
    "question_en": "What is 'unified memory' in CUDA?",
    "question_hi": "CUDA में 'unified memory' क्या है?",
    "options_en": ["Single memory space accessible from CPU and GPU", "Separate spaces", "No unification", "Only for debugging"],
    "options_hi": ["CPU और GPU से पहुंच योग्य एकल मेमोरी स्थान", "अलग-अलग स्थान", "कोई एकीकरण नहीं", "केवल डीबगिंग के लिए"],
    "answer_en": "Single memory space accessible from CPU and GPU",
    "answer_hi": "CPU और GPU से पहुंच योग्य एकल मेमोरी स्थान",
    "attempted": false,
    "selected": ""
  }
];
// --------------------------- GLOBAL VARS -----------------------------
let currentQuestion = 0;
let language = "en";
let timeLeft = 60 * 60;   // 60 minutes timer
let timerInterval;

// --------------------------- LOAD QUESTION ----------------------------
function loadQuestion(index) {
    const q = questions[index];

    document.getElementById("question").textContent =
        `${q.num}. ${language === "en" ? q.question_en : q.question_hi}`;

    document.getElementById("questionCounter").textContent =
        `Question ${index + 1} of ${questions.length}`;

    const optionsElement = document.getElementById("options");
    optionsElement.innerHTML = "";

    const options = language === "en" ? q.options_en : q.options_hi;

    options.forEach((option) => {
        const isSelected = q.selected === option;
        const optionDiv = document.createElement("div");

        optionDiv.className = "option-box";
        optionDiv.style = `
            border: 2px solid ${isSelected ? "#007bff" : "#ccc"};
            background-color: ${isSelected ? "#e7f1ff" : "white"};
            padding: 10px;
            border-radius: 8px;
            margin: 6px 0;
            cursor: pointer;
        `;

        optionDiv.innerHTML = `
            <input type="radio" name="option"
            value="${option}" ${isSelected ? "checked" : ""} /> ${option}
        `;

        optionDiv.addEventListener("click", () => {
            markAttempted(index, option);
            loadQuestion(index);
        });

        optionsElement.appendChild(optionDiv);
    });

    updateNavigation();
}

// --------------------------- MARK ATTEMPT ----------------------------
function markAttempted(index, selectedAnswer) {
    questions[index].attempted = true;
    questions[index].selected = selectedAnswer;
    updateNavigation();
}

// --------------------------- NEXT / PREV -----------------------------
function nextQuestion() {
    if (currentQuestion < questions.length - 1) {
        currentQuestion++;
        loadQuestion(currentQuestion);
    }
}

function prevQuestion() {
    if (currentQuestion > 0) {
        currentQuestion--;
        loadQuestion(currentQuestion);
    }
}

// --------------------------- LANGUAGE CHANGE -------------------------
function changeLanguage() {
    language = document.getElementById("languageSelect").value;
    loadQuestion(currentQuestion);
}

// --------------------------- TIMER -------------------------------
function startTimer() {
    const timerElement = document.getElementById("timer");
    clearInterval(timerInterval);

    timerInterval = setInterval(() => {
        if (timeLeft <= 0) {
            clearInterval(timerInterval);
            alert("⏳ Time Over!");
            submitQuiz();
            return;
        }

        const h = Math.floor(timeLeft / 3600);
        const m = Math.floor((timeLeft % 3600) / 60);
        const s = timeLeft % 60;

        timerElement.textContent =
            `Time Left: ${h.toString().padStart(2, "0")}:${m
                .toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;

        timeLeft--;
    }, 1000);
}

// --------------------------- SUBMIT QUIZ ---------------------
function submitQuiz() {
    let confirmation = confirm("Are you sure you want to submit the test?");
    if (!confirmation) return;

    clearInterval(timerInterval);

    // Calculate time spent
    const totalTimeSpent = (60 * 60) - timeLeft;
    const mins = Math.floor(totalTimeSpent / 60);
    const secs = totalTimeSpent % 60;

    // Save to localStorage
    localStorage.setItem("timeTaken", `${mins} min ${secs} sec`);

    let attempted = 0;
    let notAttempted = 0;
    let score = 0;
    const results = [];

    questions.forEach(q => {
        if (q.attempted) {
            attempted++;
            if (q.selected === q.answer_en || q.selected === q.answer_hi) {
                score++;
            }
        } else {
            notAttempted++;
        }

        results.push({
            question: language === "en" ? q.question_en : q.question_hi,
            selected: q.selected || "Not Answered",
            correct: language === "en" ? q.answer_en : q.answer_hi
        });
    });

    // Save result data
    localStorage.setItem("attempted", attempted);
    localStorage.setItem("notAttempted", notAttempted);
    localStorage.setItem("score", score);
    localStorage.setItem("results", JSON.stringify(results));

    // Stop camera stream if active
    if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
    }

    // Redirect
    window.location.href = "/RTS/public/Deshbord/category/test/submit-test.html";
}

// --------------------------- NAVIGATION ------------------------------
function updateNavigation() {
    const nav = document.getElementById("circleContainer");
    nav.innerHTML = "";

    questions.forEach((q, i) => {
        let color = "gray";
        if (i === currentQuestion) color = "blue";
        else if (q.attempted) color = "green";

        const circle = document.createElement("div");
        circle.className = "circle";
        circle.style.background = color;
        circle.textContent = i + 1;
        circle.onclick = () => jumpToQuestion(i);
        nav.appendChild(circle);
    });
}

function jumpToQuestion(i) {
    currentQuestion = i;
    loadQuestion(i);
}

// --------------------------- CAMERA ----------------------
let videoStream;

function startCamera() {
    const container = document.createElement("div");
    container.id = "camera-container";
    container.style.position = "fixed";
    container.style.top = "10px";
    container.style.left = "10px";
    container.style.width = "130px";
    container.style.height = "130px";
    container.style.borderRadius = "50%";
    container.style.overflow = "hidden";
    container.style.background = "#000";
    container.style.border = "3px solid red";
    container.style.zIndex = "9999";
    document.body.appendChild(container);

    const video = document.createElement("video");
    video.autoplay = true;
    video.playsInline = true;
    video.style.width = "100%";
    video.style.height = "100%";
    video.style.objectFit = "cover";
    container.appendChild(video);

    navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
            video.srcObject = stream;
            videoStream = stream;
        })
        .catch(() => alert("Camera not accessible!"));
}

// --------------------------- PAGE LOAD --------------------------
window.onload = function () {
    loadQuestion(currentQuestion);
    startTimer();
    startCamera();
};